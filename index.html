<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonding Layout Optimizer (v2)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        #sidebar {
            width: 280px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        h2 { font-size: 1.1rem; margin-top: 0; }
        button {
            width: 100%;
            padding: 12px;
            background-color: #87CEEB; /* LightBlue */
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background 0.2s;
        }
        button:hover { background-color: #e0f7fa; }
        .info-text {
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            color: #333;
        }
        .stats-box {
            margin-top: auto;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Bonding Optimizer</h2>
    
    <button id="btn-calc">RUN OPTIMIZATION</button>

    <div class="info-text">
HOW TO USE
------------------
1. DRAG & DROP:
   Move devices (SQD/DQD).
2. PIN ROLES:
   [Right-Click]:
   Cycle G -> S -> D
   (Smart assign active)
3. PADS:
   [Click]:
   Green (Gate) -> 
   Red (Forbidden) -> 
   Blue (RF)
    </div>
    
    <div id="stats-output" class="stats-box" style="display:none;"></div>
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<script>
/* =========================================
   Configuration & Constants
   ========================================= */
const GRID_SIZE = 12;

// Python code: PAD_CONFIG
const PAD_CONFIG = {
    'TOP':    [6, 10, 24, 7, 5, 16],
    'RIGHT':  [1, 14, 18, 19, 20, 21],
    'BOTTOM': [12, 2, 3, 4, 8, 22],
    'LEFT':   [11, 9, 23, 13, 15, 17]
};

const COLORS = {
    PAD_GATE: '#4CAF50', // 0: Green
    PAD_BAD:  '#F44336', // 1: Red
    PAD_RF:   '#2196F3', // 2: Blue
    PIN_OFF:  'rgba(0,0,0,0.5)', 
    PIN_GATE: '#FFC107', // Yellow
    PIN_RF:   '#2196F3', // Blue
    WIRE_RF:  'deepskyblue',
    WIRE_G:   'orange',
    SEL_DEV:  'purple',
    UNSEL_DEV:'gray'
};

/* =========================================
   Math & Helper Functions
   ========================================= */
function dist(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
}

// 2つの線分 (p1-p2, p3-p4) の交差判定
function checkIntersection(p1, p2, p3, p4) {
    const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
    if (d === 0) return false;
    const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
    const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;
    return (u > 0.001 && u < 0.999) && (v > 0.001 && v < 0.999);
}

/* =========================================
   Device Model (Python Class Port)
   ========================================= */
class DeviceModel {
    constructor(name, w, h, initX, initY) {
        this.name = name;
        this.w = w;
        this.h = h;
        this.pos = { x: initX, y: initY }; // Center position

        // Generate Pins
        this.pins = [];
        const x_range = [];
        for(let i=0; i<w; i++) x_range.push( -(w-1)/2 + i );
        const y_range = [];
        for(let i=0; i<h; i++) y_range.push( -(h-1)/2 + i );

        // Grid creation (meshgrid equivalent)
        for (let py of y_range) {
            for (let px of x_range) {
                this.pins.push({
                    rel: {x: px, y: py}, // Relative to device center
                    active: true,
                    role: 'G'
                });
            }
        }

        // Python: sorted_indices logic for initial S/D assignment (sort by Y)
        this.pins.sort((a,b) => a.rel.y - b.rel.y);
        this.pins[0].role = 'S';
        this.pins[this.pins.length-1].role = 'D';
    }

    getAbsPins() {
        return this.pins.map(p => ({
            x: this.pos.x + p.rel.x,
            y: this.pos.y + p.rel.y,
            active: p.active,
            role: p.role,
            originalRef: p
        }));
    }

    toggleActive(idx) {
        this.pins[idx].active = !this.pins[idx].active;
    }

    // Python: set_role_smart
    setRoleSmart(idx, newRole) {
        if (['S', 'D'].includes(newRole)) {
            // If this role exists elsewhere in THIS device, revert it to G
            const oldIdx = this.pins.findIndex(p => p.role === newRole);
            if (oldIdx !== -1) {
                this.pins[oldIdx].role = 'G';
            }
        }
        this.pins[idx].role = newRole;
    }

    // Python: cycle_role
    cycleRole(idx) {
        const curr = this.pins[idx].role;
        if (curr === 'G') this.setRoleSmart(idx, 'S');
        else if (curr === 'S') this.setRoleSmart(idx, 'D');
        else if (curr === 'D') this.pins[idx].role = 'G';
    }

    // Python: snap_to_grid
    snapToGrid(maxGrid) {
        // Logic: round(pos - 0.5) + 0.5 if even size, else round(pos)
        const snap = (val, size) => {
            return (size % 2 === 0) 
                ? Math.round(val - 0.5) + 0.5 
                : Math.round(val);
        };
        
        let tx = snap(this.pos.x, this.w);
        let ty = snap(this.pos.y, this.h);

        // Clip (keep roughly inside grid)
        tx = Math.max(0, Math.min(maxGrid, tx));
        ty = Math.max(0, Math.min(maxGrid, ty));

        this.pos.x = tx;
        this.pos.y = ty;
    }
}

/* =========================================
   Application Logic
   ========================================= */
class BondingApp {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.scale = 45; // Pixels per grid unit
        this.margin = 3; // Grid units margin
        
        // --- Initialize State ---
        // 1. Devices (SQD and DQD existing together)
        this.devices = [
            new DeviceModel('SQD', 2, 4, 3.5, 3.5),
            new DeviceModel('DQD', 2, 5, 7.5, 7.0)
        ];
        this.selectedDevIdx = 0;

        // 2. Outer Pads
        this.pads = [];
        this.padStatus = new Array(24).fill(0); // 0:G, 1:Bad, 2:RF
        this.initPads();

        // 3. Wires
        this.lines = []; // {start, end, type}

        // --- Interaction State ---
        this.dragging = false;
        this.dragOffset = {x:0, y:0};

        // --- Events ---
        this.setupEvents();
        
        // Initial Draw
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    initPads() {
        // Build pad coordinates based on configuration
        const gridMax = GRID_SIZE - 1;
        const low = -3.0;
        const high = gridMax + 3.0;
        
        // Helper to interpolate 6 points along an edge
        const linspace = (start, end, n) => {
            const arr = [];
            const step = (end - start) / (n - 1);
            for(let i=0; i<n; i++) arr.push(start + (step * i));
            return arr;
        };

        const points = linspace(0, gridMax, 6);
        const revPoints = [...points].reverse(); // 0 to gridMax, but reversed logic where needed

        // Top: y=high, x varies
        points.forEach((x, i) => this.pads.push({ x: x, y: high, label: PAD_CONFIG.TOP[i] }));
        // Right: x=high, y varies (high to low)
        revPoints.forEach((y, i) => this.pads.push({ x: high, y: y, label: PAD_CONFIG.RIGHT[i] }));
        // Bottom: y=low, x varies (high to low)
        revPoints.forEach((x, i) => this.pads.push({ x: x, y: low, label: PAD_CONFIG.BOTTOM[i] }));
        // Left: x=low, y varies (low to high)
        points.forEach((y, i) => this.pads.push({ x: low, y: y, label: PAD_CONFIG.LEFT[i] }));
    }

    /* --- Drawing --- */
    
    // Convert Logical (Grid) to Screen Pixels
    toScreen(lx, ly) {
        // Center the grid in the canvas
        const logicalW = GRID_SIZE + this.margin*2;
        const logicalH = GRID_SIZE + this.margin*2;
        
        // Canvas center
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Offset from grid center ((GRID_SIZE-1)/2)
        const gridCenter = (GRID_SIZE - 1) / 2;
        
        // Standard Cartesian: Y up. Canvas: Y down.
        // We want Y to behave like the Python plot (likely Y up visual, but let's stick to standard map).
        // Let's assume standard math coordinates where Y increases upwards.
        const px = cx + (lx - gridCenter) * this.scale;
        const py = cy - (ly - gridCenter) * this.scale;
        return {x: px, y: py};
    }

    // Convert Screen to Logical
    toLogical(sx, sy) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const gridCenter = (GRID_SIZE - 1) / 2;
        
        const lx = (sx - cx) / this.scale + gridCenter;
        const ly = gridCenter - (sy - cy) / this.scale;
        return {x: lx, y: ly};
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. Grid Background
        for (let i = 0; i < GRID_SIZE; i+=2) {
            // Draw vertical stripes
            const p1 = this.toScreen(i - 0.5, -0.5);
            const p2 = this.toScreen(i + 1.5, GRID_SIZE - 0.5);
            const x = Math.min(p1.x, p2.x);
            const w = Math.abs(p2.x - p1.x);
            const y = Math.min(p1.y, p2.y); // Top in canvas coords
            const h = Math.abs(p2.y - p1.y);
            
            ctx.fillStyle = (i/2)%2===0 ? '#f0f0f0' : '#e0e0e0';
            ctx.fillRect(x, y, w, h);
        }

        // Grid Dots
        ctx.fillStyle = 'gray';
        for(let gx=0; gx<GRID_SIZE; gx++){
            for(let gy=0; gy<GRID_SIZE; gy++){
                const p = this.toScreen(gx, gy);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // 2. Pads
        this.pads.forEach((pad, i) => {
            const p = this.toScreen(pad.x, pad.y);
            const st = this.padStatus[i];
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
            if (st === 0) ctx.fillStyle = COLORS.PAD_GATE;
            else if (st === 1) ctx.fillStyle = COLORS.PAD_BAD;
            else ctx.fillStyle = COLORS.PAD_RF;
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(pad.label, p.x, p.y);
        });

        // 3. Devices
        this.devices.forEach((dev, idx) => {
            const isSel = (idx === this.selectedDevIdx);
            const center = this.toScreen(dev.pos.x, dev.pos.y);
            
            // Body
            const wPx = dev.w * this.scale;
            const hPx = dev.h * this.scale;
            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.fillStyle = isSel ? 'rgba(128,0,128,0.1)' : 'rgba(128,128,128,0.1)';
            ctx.strokeStyle = isSel ? COLORS.SEL_DEV : COLORS.UNSEL_DEV;
            ctx.lineWidth = 2;
            ctx.fillRect(-wPx/2, -hPx/2, wPx, hPx);
            ctx.strokeRect(-wPx/2, -hPx/2, wPx, hPx);
            
            // Name
            ctx.fillStyle = ctx.strokeStyle;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(dev.name, 0, -hPx/2 - 12);
            ctx.restore();

            // Pins
            const absPins = dev.getAbsPins();
            absPins.forEach(pin => {
                const p = this.toScreen(pin.x, pin.y);
                if (!pin.active) {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    const r = 6;
                    ctx.beginPath();
                    ctx.moveTo(p.x-r, p.y-r); ctx.lineTo(p.x+r, p.y+r);
                    ctx.moveTo(p.x+r, p.y-r); ctx.lineTo(p.x-r, p.y+r);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                    const isRF = ['S','D'].includes(pin.role);
                    ctx.fillStyle = isRF ? COLORS.PIN_RF : COLORS.PIN_GATE;
                    ctx.fill();
                    ctx.stroke();
                    
                    if (isRF) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 9px Arial';
                        ctx.fillText(pin.role, p.x, p.y);
                    }
                }
            });
        });

        // 4. Wires
        let crossing = false;
        // Check crossing for display warning
        for(let i=0; i<this.lines.length; i++){
            for(let j=i+1; j<this.lines.length; j++){
                if(checkIntersection(this.lines[i].start, this.lines[i].end, this.lines[j].start, this.lines[j].end)){
                    crossing = true;
                }
            }
        }

        this.lines.forEach(line => {
            const p1 = this.toScreen(line.start.x, line.start.y);
            const p2 = this.toScreen(line.end.x, line.end.y);
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineWidth = (line.type === 'RF') ? 3 : 1.5;
            ctx.strokeStyle = (line.type === 'RF') ? COLORS.WIRE_RF : COLORS.WIRE_G;
            ctx.globalAlpha = 0.8;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        });

        if (crossing) {
            ctx.fillStyle = 'red';
            ctx.font = 'bold 16px Arial';
            ctx.fillText("WARNING: WIRES CROSSING!", this.canvas.width/2, this.canvas.height - 30);
        }
    }

    resize() {
        const el = document.getElementById('canvas-container');
        this.canvas.width = el.clientWidth;
        this.canvas.height = el.clientHeight;
        this.draw();
    }

    /* --- Events --- */
    setupEvents() {
        // Helper to get logical coords
        const getM = (e) => {
            const r = this.canvas.getBoundingClientRect();
            return this.toLogical(e.clientX - r.left, e.clientY - r.top);
        };

        this.canvas.addEventListener('mousedown', (e) => {
            const m = getM(e);
            
            // 1. Check Device Pins
            let hit = false;
            this.devices.forEach((dev, di) => {
                dev.getAbsPins().forEach((pin, pi) => {
                    if (dist(m.x, m.y, pin.x, pin.y) < 0.4) {
                        // Found a pin
                        if (e.button === 0) { // Left Click: Toggle Active
                            dev.toggleActive(pi);
                        }
                        // Note: Right click handled in contextmenu
                        hit = true;
                        this.lines = []; // Reset wires
                        this.draw();
                    }
                });
            });
            if (hit) return;

            // 2. Check Pads
            this.pads.forEach((pad, pi) => {
                if (dist(m.x, m.y, pad.x, pad.y) < 0.8) {
                    this.padStatus[pi] = (this.padStatus[pi] + 1) % 3;
                    this.lines = [];
                    this.draw();
                    hit = true;
                }
            });
            if (hit) return;

            // 3. Check Device Body (Selection & Drag)
            this.devices.forEach((dev, di) => {
                const dx = Math.abs(m.x - dev.pos.x);
                const dy = Math.abs(m.y - dev.pos.y);
                if (dx < dev.w/2 && dy < dev.h/2) {
                    this.selectedDevIdx = di;
                    this.dragging = true;
                    this.dragOffset = { x: dev.pos.x - m.x, y: dev.pos.y - m.y };
                    this.lines = [];
                    this.draw();
                    hit = true;
                }
            });
        });

        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.dragging) return;
            const m = getM(e);
            const dev = this.devices[this.selectedDevIdx];
            dev.pos.x = m.x + this.dragOffset.x;
            dev.pos.y = m.y + this.dragOffset.y;
            this.lines = [];
            this.draw();
        });

        this.canvas.addEventListener('mouseup', () => {
            if (this.dragging) {
                this.dragging = false;
                const dev = this.devices[this.selectedDevIdx];
                dev.snapToGrid(GRID_SIZE - 1);
                this.draw();
            }
        });

        // Right Click: Pin Role Cycling
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const m = getM(e);
            
            this.devices.forEach((dev) => {
                dev.getAbsPins().forEach((pin, pi) => {
                    if (dist(m.x, m.y, pin.x, pin.y) < 0.4) {
                        dev.cycleRole(pi);
                        this.lines = [];
                        this.draw();
                    }
                });
            });
        });

        // Optimization Button
        document.getElementById('btn-calc').addEventListener('click', () => {
            this.runOptimization();
        });
    }

    /* --- Optimization Logic (Simulating Python's solver) --- */
    runOptimization() {
        // Collect ALL active pins from ALL devices
        let allPins = [];
        this.devices.forEach((dev, dIdx) => {
            const abs = dev.getAbsPins();
            abs.forEach((p, pIdx) => {
                if(p.active) {
                    allPins.push({
                        x: p.x, y: p.y,
                        role: p.role,
                        devIdx: dIdx,
                        originalIdx: pIdx
                    });
                }
            });
        });

        // Available Pads
        const availPads = [];
        this.pads.forEach((p, idx) => {
            if (this.padStatus[idx] !== 1) { // Not Forbidden
                availPads.push({
                    x: p.x, y: p.y,
                    status: this.padStatus[idx], // 0 or 2
                    originalIdx: idx
                });
            }
        });

        // --- Solver ---
        // Constraint: 'G' pins -> Pad Status 0
        //             'S'/'D' pins -> Pad Status 0 or 2
        // Prefer RF pads for RF pins.

        const N = allPins.length;
        if (N === 0) return;

        // Determine allowed pads per pin
        const allowed = allPins.map(pin => {
            return availPads.filter(pad => {
                if (pin.role === 'G') return pad.status === 0;
                else return true; // S/D can go to 0 or 2
            }).map(p => p.originalIdx);
        });

        // Current best
        let bestAssign = new Array(N).fill(-1);
        let minCost = Infinity;

        // Helper: Calculate Cost
        // Cost = (Crossings * 1e6) + (MissingRF * 2e5) + Length
        const calcCost = (assignment) => {
            const segs = [];
            let lenSum = 0;
            let missingRF = 0;

            for(let i=0; i<N; i++) {
                if (assignment[i] === -1) continue;
                const pin = allPins[i];
                const padIdx = assignment[i];
                const pad = this.pads[padIdx];
                const padSt = this.padStatus[padIdx];

                // Length
                lenSum += dist(pin.x, pin.y, pad.x, pad.y);
                segs.push({p1: pin, p2: pad});

                // Missing RF Check
                if (['S','D'].includes(pin.role) && padSt !== 2) {
                    missingRF++;
                }
            }

            let crosses = 0;
            for(let i=0; i<segs.length; i++){
                for(let j=i+1; j<segs.length; j++){
                    if(checkIntersection(segs[i].p1, segs[i].p2, segs[j].p1, segs[j].p2)){
                        crosses++;
                    }
                }
            }
            
            return {
                val: (crosses * 1e6) + (missingRF * 2e5) + lenSum,
                crosses, missingRF, lenSum
            };
        };

        // Initialize: Nearest Neighbor (Greedy)
        // Sort pins so RF pins get first dibs on RF pads
        const pinOrder = allPins.map((_, i) => i).sort((a,b) => {
            const isRF_a = (allPins[a].role !== 'G');
            const isRF_b = (allPins[b].role !== 'G');
            if (isRF_a && !isRF_b) return -1;
            if (!isRF_a && isRF_b) return 1;
            return 0;
        });

        let currentAssign = new Array(N).fill(-1);
        let usedPads = new Set();

        pinOrder.forEach(i => {
            let bestP = -1; 
            let minD = Infinity;
            // Prefer RF pad if RF pin
            const isRF = (allPins[i].role !== 'G');
            
            allowed[i].forEach(pid => {
                if(usedPads.has(pid)) return;
                
                let d = dist(allPins[i].x, allPins[i].y, this.pads[pid].x, this.pads[pid].y);
                
                // Heuristic bias: if pin is RF and pad is RF, huge bonus (negative distance)
                if (isRF && this.padStatus[pid] === 2) d -= 1000;
                
                if (d < minD) {
                    minD = d;
                    bestP = pid;
                }
            });
            
            if (bestP !== -1) {
                currentAssign[i] = bestP;
                usedPads.add(bestP);
            }
        });

        // Iterative Improvement (Deterministic Swap like Python script)
        let costObj = calcCost(currentAssign);
        let improved = true;
        let loop = 0;

        while(improved && loop < 100) {
            improved = false;
            loop++;

            // Try swapping any two assignments
            for(let i=0; i<N; i++) {
                for(let j=i+1; j<N; j++) {
                    const pid1 = currentAssign[i];
                    const pid2 = currentAssign[j];
                    if (pid1 === -1 || pid2 === -1) continue;

                    // Check if swap is valid
                    if (!allowed[i].includes(pid2) || !allowed[j].includes(pid1)) continue;

                    // Swap
                    currentAssign[i] = pid2;
                    currentAssign[j] = pid1;
                    
                    const newCost = calcCost(currentAssign);
                    if (newCost.val < costObj.val - 0.001) {
                        costObj = newCost;
                        improved = true;
                    } else {
                        // Revert
                        currentAssign[i] = pid1;
                        currentAssign[j] = pid2;
                    }
                }
            }
            
            // Try swapping assigned with unassigned
            const used = new Set(currentAssign.filter(x => x !== -1));
            const unused = availPads.map(p => p.originalIdx).filter(pid => !used.has(pid));
            
            for(let i=0; i<N; i++) {
                const oldPid = currentAssign[i];
                if (oldPid === -1) continue;

                for (let uPid of unused) {
                    if (allowed[i].includes(uPid)) {
                        currentAssign[i] = uPid;
                        const newCost = calcCost(currentAssign);
                        if (newCost.val < costObj.val - 0.001) {
                            // Update unused list logic simply by restarting loop next time or simple swap
                            costObj = newCost;
                            improved = true;
                            // Update our local tracking
                            used.delete(oldPid); used.add(uPid);
                            const uIdx = unused.indexOf(uPid);
                            unused[uIdx] = oldPid; 
                        } else {
                            currentAssign[i] = oldPid;
                        }
                    }
                }
            }
        }

        // Generate Result Lines
        this.lines = [];
        for(let i=0; i<N; i++){
            const pid = currentAssign[i];
            if (pid !== -1) {
                const pin = allPins[i];
                const pad = this.pads[pid];
                const isRF = (['S','D'].includes(pin.role) && this.padStatus[pid] === 2);
                this.lines.push({
                    start: {x: pin.x, y: pin.y},
                    end: {x: pad.x, y: pad.y},
                    type: isRF ? 'RF' : 'Gate'
                });
            }
        }

        // Update UI
        const statEl = document.getElementById('stats-output');
        statEl.style.display = 'block';
        statEl.innerHTML = `
CROSSINGS: ${costObj.crosses}
MISS RF:   ${costObj.missingRF}
LENGTH:    ${costObj.lenSum.toFixed(1)}
        `;

        this.draw();
    }
}

// Start
window.onload = () => { new BondingApp(); };
</script>
</body>
</html>
