<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonding Layout Optimizer Pro v4</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --sidebar-bg: #0f172a;
            --sidebar-text: #e2e8f0;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
            --canvas-bg: #f1f5f9;
            --panel-bg: #1e293b;
            --border-color: #334155;
            
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            background-color: var(--canvas-bg);
            color: #333;
            overflow: hidden;
        }

        #sidebar {
            width: 340px;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 4px 0 20px rgba(0,0,0,0.1);
            z-index: 10;
            overflow-y: auto;
        }

        .brand {
            font-size: 1.25rem;
            font-weight: 800;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            letter-spacing: -0.02em;
        }
        .brand span { color: var(--accent-color); }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #94a3b8;
            margin-bottom: 10px;
            margin-top: 20px;
            font-weight: 700;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 4px;
        }
        .section-title:first-of-type { margin-top: 0; }

        .btn-primary {
            width: 100%;
            padding: 14px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }
        .stat-card {
            background-color: var(--panel-bg);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        .stat-label { font-size: 0.65rem; color: #94a3b8; text-transform: uppercase; }
        .stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.0rem; font-weight: 700; margin-top: 2px; }
        .stat-value.danger { color: var(--danger); }
        .stat-value.success { color: var(--success); }

        #connection-output {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }
        .dev-group {
            margin-bottom: 16px;
            background: var(--panel-bg);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        .dev-header {
            background: #28364d;
            padding: 6px 12px;
            font-weight: 700;
            font-size: 0.8rem;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .conn-row {
            padding: 6px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            color: #cbd5e1;
            align-items: center;
        }
        .conn-row:last-child { border-bottom: none; }
        .conn-role {
            display: inline-block;
            width: 24px;
            text-align: center;
            font-weight: bold;
            margin-right: 8px;
            border-radius: 4px;
        }
        .role-G { color: #eab308; }
        .role-S, .role-D { color: #3b82f6; background: rgba(59, 130, 246, 0.1); }
        .pad-badge {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
        }
        .pad-badge.is-rf {
            background: rgba(37, 99, 235, 0.3);
            color: #60a5fa;
            border: 1px solid rgba(37, 99, 235, 0.5);
        }
        .alert-box {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.8rem;
            display: none;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: var(--canvas-bg);
            background-image: 
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: 40px 40px; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        canvas {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="brand">
        <span>⚡</span> Bonding Optimizer
    </div>
    
    <div class="section-title">Action</div>
    <button id="btn-calc" class="btn-primary">Optimize Connections</button>
    
    <div id="alert-area" style="margin-top: 15px;">
        <div id="alert-cross" class="alert-box">⚠️ Wire Crossing Detected</div>
        <div id="alert-rf" class="alert-box">⚠️ Critical: RF Pad Missing!</div>
    </div>

    <div class="section-title">Statistics</div>
    <div class="stats-container">
        <div class="stat-card">
            <div class="stat-label">Crossings</div>
            <div class="stat-value" id="stat-cross">-</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Critical Miss</div>
            <div class="stat-value" id="stat-crit">-</div>
        </div>
        <div class="stat-card" style="grid-column: span 2;">
            <div class="stat-label">Total Wire Length</div>
            <div class="stat-value" id="stat-len">-</div>
        </div>
    </div>

    <div class="section-title">Connection List</div>
    <div id="connection-output">
        <div style="color: #64748b; font-style: italic; padding: 10px;">
            Run optimization to see results.
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<script>
const GRID_SIZE = 12;

const PAD_CONFIG = {
    'TOP':    [6, 10, 24, 7, 5, 16],
    'RIGHT':  [1, 14, 18, 19, 20, 21],
    'BOTTOM': [12, 2, 3, 4, 8, 22],
    'LEFT':   [11, 9, 23, 13, 15, 17]
};

const COLORS = {
    GRID_BG_1: '#ffffff',
    GRID_BG_2: '#f8fafc',
    GRID_DOT:  '#cbd5e1',
    GRID_BORDER: '#334155', // Darker border
    
    PAD_GATE: '#16a34a',
    PAD_BAD:  '#dc2626',
    PAD_RF:   '#2563eb',
    PAD_TEXT: '#ffffff',
    
    PIN_OFF:  '#cbd5e1',
    PIN_GATE: '#eab308',
    PIN_RF:   '#2563eb',
    
    WIRE_RF:  '#2563eb',
    WIRE_G:   '#f59e0b',
    
    DEV_STROKE: '#475569',
    DEV_FILL:   'rgba(71, 85, 105, 0.03)',
    DEV_SEL:    '#7c3aed'
};

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
}

function checkIntersection(p1, p2, p3, p4) {
    const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
    if (d === 0) return false;
    const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
    const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;
    return (u > 0.001 && u < 0.999) && (v > 0.001 && v < 0.999);
}

class DeviceModel {
    constructor(name, w, h, initX, initY) {
        this.name = name;
        this.w = w;
        this.h = h;
        this.pos = { x: initX, y: initY }; 
        this.pins = [];
        
        const x_range = Array.from({length:w}, (_,i) => -(w-1)/2 + i);
        const y_range = Array.from({length:h}, (_,i) => -(h-1)/2 + i);

        for (let py of y_range) {
            for (let px of x_range) {
                this.pins.push({rel: {x: px, y: py}, active: true, role: 'G'});
            }
        }
        this.pins.sort((a,b) => a.rel.y - b.rel.y);
        this.pins[0].role = 'S';
        this.pins[this.pins.length-1].role = 'D';
    }

    getAbsPins() {
        return this.pins.map((p, i) => ({
            x: this.pos.x + p.rel.x,
            y: this.pos.y + p.rel.y,
            active: p.active,
            role: p.role,
            relX: p.rel.x,
            relY: p.rel.y,
            index: i
        }));
    }

    toggleActive(idx) { this.pins[idx].active = !this.pins[idx].active; }
    
    setRoleSmart(idx, newRole) {
        if (['S', 'D'].includes(newRole)) {
            const oldIdx = this.pins.findIndex(p => p.role === newRole);
            if (oldIdx !== -1) this.pins[oldIdx].role = 'G';
        }
        this.pins[idx].role = newRole;
    }

    cycleRole(idx) {
        const curr = this.pins[idx].role;
        if (curr === 'G') this.setRoleSmart(idx, 'S');
        else if (curr === 'S') this.setRoleSmart(idx, 'D');
        else if (curr === 'D') this.pins[idx].role = 'G';
    }

    snapToGrid(maxGrid) {
        const snap = (val, size) => (size % 2 === 0) ? Math.round(val - 0.5) + 0.5 : Math.round(val);
        this.pos.x = Math.max(0, Math.min(maxGrid, snap(this.pos.x, this.w)));
        this.pos.y = Math.max(0, Math.min(maxGrid, snap(this.pos.y, this.h)));
    }
}

class BondingApp {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.scale = 45; 
        this.margin = 3; 

        this.devices = [
            new DeviceModel('SQD', 2, 4, 3.5, 3.5),
            new DeviceModel('DQD', 2, 5, 7.5, 7.0)
        ];
        this.selectedDevIdx = 0;
        
        this.pads = [];
        this.padStatus = new Array(24).fill(0); 
        this.initPads();

        this.lines = [];
        this.dragging = false;
        this.dragOffset = {x:0, y:0};

        this.setupEvents();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.draw();
    }

    initPads() {
        const gridMax = GRID_SIZE - 1;
        const low = -3.0, high = gridMax + 3.0;
        const linspace = (s, e, n) => Array.from({length:n}, (_,i) => s + (e-s)/(n-1)*i);
        const pts = linspace(0, gridMax, 6);
        const rpts = [...pts].reverse(); 

        pts.forEach((x, i) => this.pads.push({ x, y: high, label: PAD_CONFIG.TOP[i] }));
        rpts.forEach((y, i) => this.pads.push({ x: high, y, label: PAD_CONFIG.RIGHT[i] }));
        rpts.forEach((x, i) => this.pads.push({ x, y: low, label: PAD_CONFIG.BOTTOM[i] }));
        pts.forEach((y, i) => this.pads.push({ x: low, y, label: PAD_CONFIG.LEFT[i] }));
    }

    toScreen(lx, ly) {
        const cx = this.canvas.width/2, cy = this.canvas.height/2;
        const gc = (GRID_SIZE-1)/2;
        return { x: cx + (lx-gc)*this.scale, y: cy - (ly-gc)*this.scale };
    }

    toLogical(sx, sy) {
        const cx = this.canvas.width/2, cy = this.canvas.height/2;
        const gc = (GRID_SIZE-1)/2;
        return { x: (sx-cx)/this.scale + gc, y: gc - (sy-cy)/this.scale };
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. Grid Background & Border
        // Grid is from -0.5 to 11.5 logically
        const gridStart = this.toScreen(-0.5, -0.5); // Bottom-Left (due to Y inversion logic in toScreen)
        const gridEnd = this.toScreen(GRID_SIZE-0.5, GRID_SIZE-0.5); // Top-Right
        
        // Determine actual bounding box
        const gx = Math.min(gridStart.x, gridEnd.x);
        const gy = Math.min(gridStart.y, gridEnd.y);
        const gw = Math.abs(gridEnd.x - gridStart.x);
        const gh = Math.abs(gridEnd.y - gridStart.y);

        // Grid Stripes
        for (let i=0; i<GRID_SIZE; i+=2) {
            const p1 = this.toScreen(i-0.5, -0.5);
            const p2 = this.toScreen(i+1.5, GRID_SIZE-0.5);
            const x = Math.min(p1.x, p2.x), y = Math.min(p1.y, p2.y);
            const w = Math.abs(p2.x-p1.x), h = Math.abs(p2.y-p1.y);
            ctx.fillStyle = (i/2)%2===0 ? COLORS.GRID_BG_1 : COLORS.GRID_BG_2;
            ctx.fillRect(x, y, w, h);
        }

        // Draw Thick Border around 12x12
        ctx.strokeStyle = COLORS.GRID_BORDER;
        ctx.lineWidth = 3;
        ctx.strokeRect(gx, gy, gw, gh);

        // Grid Dots
        ctx.fillStyle = COLORS.GRID_DOT;
        for(let gx=0; gx<GRID_SIZE; gx++){
            for(let gy=0; gy<GRID_SIZE; gy++){
                const p = this.toScreen(gx, gy);
                ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2); ctx.fill();
            }
        }

        // Pads
        this.pads.forEach((pad, i) => {
            const p = this.toScreen(pad.x, pad.y);
            const st = this.padStatus[i];
            ctx.shadowColor = 'rgba(0,0,0,0.15)'; ctx.shadowBlur = 6; ctx.shadowOffsetY = 3;
            ctx.beginPath(); ctx.arc(p.x, p.y, 17, 0, Math.PI*2);
            ctx.fillStyle = st===0 ? COLORS.PAD_GATE : (st===1 ? COLORS.PAD_BAD : COLORS.PAD_RF);
            ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.fillStyle = COLORS.PAD_TEXT;
            ctx.font = 'bold 13px "JetBrains Mono"';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(pad.label, p.x, p.y + 1);
        });

        // Devices
        this.devices.forEach((dev, idx) => {
            const isSel = (idx === this.selectedDevIdx);
            const center = this.toScreen(dev.pos.x, dev.pos.y);
            const wPx = dev.w * this.scale, hPx = dev.h * this.scale;
            ctx.save(); ctx.translate(center.x, center.y);
            ctx.fillStyle = COLORS.DEV_FILL;
            ctx.strokeStyle = isSel ? COLORS.DEV_SEL : COLORS.DEV_STROKE;
            ctx.lineWidth = isSel ? 3 : 2;
            ctx.beginPath(); ctx.roundRect(-wPx/2, -hPx/2, wPx, hPx, 8); ctx.fill(); ctx.stroke();
            ctx.fillStyle = ctx.strokeStyle; ctx.font = 'bold 14px Inter';
            ctx.fillText(dev.name, 0, -hPx/2 - 16);
            ctx.restore();

            dev.getAbsPins().forEach(pin => {
                const p = this.toScreen(pin.x, pin.y);
                const isRF = ['S','D'].includes(pin.role);
                ctx.beginPath();
                if (!pin.active) {
                    ctx.strokeStyle = COLORS.PIN_OFF; ctx.lineWidth = 2;
                    ctx.moveTo(p.x-4, p.y-4); ctx.lineTo(p.x+4, p.y+4);
                    ctx.moveTo(p.x+4, p.y-4); ctx.lineTo(p.x-4, p.y+4);
                    ctx.stroke();
                } else {
                    ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                    ctx.fillStyle = isRF ? COLORS.PIN_RF : COLORS.PIN_GATE;
                    ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    if (isRF) {
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 9px Inter';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(pin.role, p.x, p.y);
                    }
                }
            });
        });

        // Wires
        let crossing = false;
        for(let i=0; i<this.lines.length; i++){
            for(let j=i+1; j<this.lines.length; j++){
                if(checkIntersection(this.lines[i].start, this.lines[i].end, this.lines[j].start, this.lines[j].end)) crossing = true;
            }
        }
        this.lines.forEach(line => {
            const p1 = this.toScreen(line.start.x, line.start.y);
            const p2 = this.toScreen(line.end.x, line.end.y);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            const isRF = (line.type === 'RF');
            ctx.lineWidth = isRF ? 3.5 : 2;
            ctx.strokeStyle = isRF ? COLORS.WIRE_RF : COLORS.WIRE_G;
            ctx.lineCap = 'round'; ctx.globalAlpha = 0.8; ctx.stroke(); ctx.globalAlpha = 1.0;
        });

        if (crossing) {
            ctx.fillStyle = COLORS.PAD_BAD; ctx.font = 'bold 16px Inter'; ctx.textAlign = 'center';
            ctx.fillText("⚠️ CROSSING DETECTED", this.canvas.width/2, this.canvas.height - 30);
        }
    }

    resize() {
        const c = document.getElementById('canvas-container');
        this.canvas.width = c.clientWidth; this.canvas.height = c.clientHeight;
        const minDim = Math.min(this.canvas.width, this.canvas.height);
        this.scale = minDim / (GRID_SIZE + this.margin*2);
        this.draw();
    }

    setupEvents() {
        const getM = (e) => {
            const r = this.canvas.getBoundingClientRect();
            return this.toLogical(e.clientX - r.left, e.clientY - r.top);
        };
        this.canvas.addEventListener('mousedown', (e) => {
            const m = getM(e);
            let needsDraw = false;
            let pinHit = false;
            this.devices.forEach((dev) => {
                dev.getAbsPins().forEach((pin, pi) => {
                    if (dist(m.x, m.y, pin.x, pin.y) < 0.5) {
                        if (e.button === 0) dev.toggleActive(pi);
                        this.lines = []; this.updateList(); pinHit = true; needsDraw = true;
                    }
                });
            });
            if (pinHit) { this.draw(); return; }

            this.pads.forEach((pad, pi) => {
                if (dist(m.x, m.y, pad.x, pad.y) < 0.9) {
                    this.padStatus[pi] = (this.padStatus[pi] + 1) % 3;
                    this.lines = []; this.updateList(); needsDraw = true;
                }
            });
            if (needsDraw) { this.draw(); return; }

            this.devices.forEach((dev, di) => {
                if (Math.abs(m.x-dev.pos.x) < dev.w/2 && Math.abs(m.y-dev.pos.y) < dev.h/2) {
                    this.selectedDevIdx = di; this.dragging = true;
                    this.dragOffset = { x: dev.pos.x - m.x, y: dev.pos.y - m.y };
                    this.lines = []; this.updateList(); this.draw();
                }
            });
        });
        this.canvas.addEventListener('mousemove', (e) => {
            if (this.dragging) {
                const m = getM(e);
                const dev = this.devices[this.selectedDevIdx];
                dev.pos.x = m.x + this.dragOffset.x; dev.pos.y = m.y + this.dragOffset.y;
                this.draw();
            }
        });
        this.canvas.addEventListener('mouseup', () => {
            if (this.dragging) {
                this.dragging = false; this.devices[this.selectedDevIdx].snapToGrid(GRID_SIZE-1); this.draw();
            }
        });
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); const m = getM(e); let hit=false;
            this.devices.forEach((dev) => {
                dev.getAbsPins().forEach((pin, pi) => {
                    if (dist(m.x, m.y, pin.x, pin.y) < 0.5) {
                        dev.cycleRole(pi); this.lines = []; this.updateList(); hit = true;
                    }
                });
            });
            if (hit) this.draw();
        });
        document.getElementById('btn-calc').addEventListener('click', () => {
            const btn = document.getElementById('btn-calc');
            btn.textContent = "Calculating...";
            setTimeout(() => { this.runOptimization(); btn.textContent = "Optimize Connections"; }, 10);
        });
    }

    runOptimization() {
        // 1. Setup Data
        let allPins = [];
        this.devices.forEach((dev, dIdx) => {
            dev.getAbsPins().forEach((p, pIdx) => {
                if(p.active) {
                    allPins.push({
                        x: p.x, y: p.y, role: p.role, 
                        devIdx: dIdx, originalIdx: pIdx,
                        devName: dev.name
                    });
                }
            });
        });
        const availPads = [];
        this.pads.forEach((p, idx) => {
            if (this.padStatus[idx] !== 1) {
                availPads.push({x: p.x, y: p.y, status: this.padStatus[idx], originalIdx: idx, label: p.label});
            }
        });

        const N = allPins.length;
        if (N === 0) return;

        const allowed = allPins.map(pin => {
            return availPads.filter(pad => {
                if (pin.role === 'G') return pad.status === 0;
                else return true;
            }).map(p => p.originalIdx);
        });

        // 2. Cost Function (Corrected for "At least 1 RF")
        const calcCost = (assignment) => {
            const segs = [];
            let lenSum = 0;
            let missingRFPref = 0; 
            let deviceHasRF = new Array(this.devices.length).fill(false);
            
            for(let i=0; i<N; i++) {
                if (assignment[i] === -1) continue;
                const pin = allPins[i];
                const padIdx = assignment[i];
                const pad = this.pads[padIdx];
                const padSt = this.padStatus[padIdx];
                
                lenSum += dist(pin.x, pin.y, pad.x, pad.y);
                segs.push({p1: pin, p2: pad});

                const isRFPin = ['S','D'].includes(pin.role);
                if (isRFPin) {
                    if (padSt === 2) {
                        deviceHasRF[pin.devIdx] = true; 
                    } else {
                        // S/D connected to Gate Pad (preference penalty only)
                        // If logic: "Either is fine", then this penalty should be mild if device already has RF.
                        // But let's keep it moderate to encourage dual connection if easy.
                        missingRFPref++;
                    }
                }
            }

            // Critical Constraint: Each device with active S/D must have >=1 RF pad connection
            let criticalMiss = 0;
            for(let d=0; d<this.devices.length; d++) {
                const hasActiveRFPins = allPins.some(p => p.devIdx === d && ['S','D'].includes(p.role));
                if (hasActiveRFPins && !deviceHasRF[d]) {
                    criticalMiss++;
                }
            }

            let crosses = 0;
            for(let i=0; i<segs.length; i++){
                for(let j=i+1; j<segs.length; j++){
                    if(checkIntersection(segs[i].p1, segs[i].p2, segs[j].p1, segs[j].p2)) crosses++;
                }
            }

            return { 
                val: (criticalMiss * 5e6) + (crosses * 1e6) + (missingRFPref * 1e4) + lenSum, 
                crosses, criticalMiss, missingRFPref, lenSum 
            };
        };

        // 3. Init (Greedy)
        const pinOrder = allPins.map((_, i) => i).sort((a,b) => {
            const isRF_a = (allPins[a].role !== 'G');
            const isRF_b = (allPins[b].role !== 'G');
            if (isRF_a && !isRF_b) return -1;
            if (!isRF_a && isRF_b) return 1;
            return 0;
        });

        let currentAssign = new Array(N).fill(-1);
        let usedPads = new Set();
        pinOrder.forEach(i => {
            let bestP = -1, minD = Infinity;
            const isRF = (allPins[i].role !== 'G');
            allowed[i].forEach(pid => {
                if(usedPads.has(pid)) return;
                let d = dist(allPins[i].x, allPins[i].y, this.pads[pid].x, this.pads[pid].y);
                if (isRF && this.padStatus[pid] === 2) d -= 1000;
                if (d < minD) { minD = d; bestP = pid; }
            });
            if (bestP !== -1) { currentAssign[i] = bestP; usedPads.add(bestP); }
        });

        // 4. Optimize
        let costObj = calcCost(currentAssign);
        let improved = true;
        let loop = 0;
        
        while(improved && loop < 300) {
            improved = false; loop++;
            
            // Swap
            for(let i=0; i<N; i++) {
                for(let j=i+1; j<N; j++) {
                    const p1 = currentAssign[i], p2 = currentAssign[j];
                    if (p1 === -1 || p2 === -1) continue;
                    if (!allowed[i].includes(p2) || !allowed[j].includes(p1)) continue;
                    currentAssign[i] = p2; currentAssign[j] = p1;
                    const newCost = calcCost(currentAssign);
                    if (newCost.val < costObj.val - 0.001) { costObj = newCost; improved = true; }
                    else { currentAssign[i] = p1; currentAssign[j] = p2; }
                }
            }
            
            // Move to Unused
            const usedSet = new Set(currentAssign.filter(x => x !== -1));
            const unusedPads = availPads.map(p => p.originalIdx).filter(pid => !usedSet.has(pid));
            
            for(let i=0; i<N; i++) {
                const currPid = currentAssign[i];
                if (currPid === -1) continue;
                for(let uIdx=0; uIdx<unusedPads.length; uIdx++) {
                    const uPid = unusedPads[uIdx];
                    if (allowed[i].includes(uPid)) {
                        currentAssign[i] = uPid;
                        const newCost = calcCost(currentAssign);
                        if (newCost.val < costObj.val - 0.001) {
                            costObj = newCost; improved = true;
                            usedSet.delete(currPid); usedSet.add(uPid);
                            unusedPads[uIdx] = currPid; break;
                        } else { currentAssign[i] = currPid; }
                    }
                }
            }
        }

        // 5. Result
        this.lines = [];
        for(let i=0; i<N; i++){
            const pid = currentAssign[i];
            if (pid !== -1) {
                const pin = allPins[i];
                const pad = this.pads[pid];
                const isRF = (['S','D'].includes(pin.role) && this.padStatus[pid] === 2);
                this.lines.push({
                    start: {x: pin.x, y: pin.y}, end: {x: pad.x, y: pad.y},
                    type: isRF ? 'RF' : 'Gate',
                    devIdx: pin.devIdx, role: pin.role, padLabel: pad.label, isRFPad: this.padStatus[pid]===2
                });
            }
        }
        this.updateStats(costObj);
        this.updateList();
        this.draw();
    }

    updateStats(stats) {
        const setVal = (id, val, bad) => {
            const el = document.getElementById(id);
            el.textContent = val; el.className = 'stat-value ' + (bad ? 'danger' : 'success');
        };
        setVal('stat-cross', stats.crosses, stats.crosses > 0);
        setVal('stat-crit', stats.criticalMiss, stats.criticalMiss > 0);
        document.getElementById('stat-len').textContent = stats.lenSum.toFixed(1);

        document.getElementById('alert-cross').style.display = stats.crosses > 0 ? 'block' : 'none';
        document.getElementById('alert-rf').style.display = stats.criticalMiss > 0 ? 'block' : 'none';
    }

    updateList() {
        const container = document.getElementById('connection-output');
        document.getElementById('alert-cross').style.display = 'none';
        document.getElementById('alert-rf').style.display = 'none';

        if (this.lines.length === 0) {
            container.innerHTML = `<div style="color: #64748b; font-style: italic; padding: 10px;">Run optimization to see results.</div>`;
            return;
        }

        let html = '';
        this.devices.forEach((dev, dIdx) => {
            const lines = this.lines.filter(l => l.devIdx === dIdx);
            if (lines.length === 0) return;
            lines.sort((a, b) => {
                const rs = (r) => { if(r==='S') return 0; if(r==='D') return 1; return 2; };
                return rs(a.role) - rs(b.role);
            });

            // "At least one RF" check for UI Alert
            const hasS = lines.some(l => l.role === 'S');
            const hasD = lines.some(l => l.role === 'D');
            const connectedRF = lines.some(l => (l.role === 'S' || l.role === 'D') && l.isRFPad);
            const critMiss = (hasS || hasD) && !connectedRF;

            const headerStyle = critMiss ? 'background:#ef4444;' : '';

            html += `<div class="dev-group" style="${critMiss ? 'border:1px solid red' : ''}">`;
            html += `<div class="dev-header" style="${headerStyle}">${dev.name} ${critMiss ? '⚠️ NO RF' : ''}</div>`;
            lines.forEach(l => {
                const roleClass = `role-${l.role}`;
                const rfBadge = l.isRFPad ? 'is-rf' : '';
                html += `<div class="conn-row">`;
                html += `<div><span class="conn-role ${roleClass}">${l.role}</span> pin</div>`;
                html += `<div>⟶ <span class="pad-badge ${rfBadge}">Pad ${l.padLabel}</span></div>`;
                html += `</div>`;
            });
            html += `</div>`;
        });
        container.innerHTML = html;
    }
}

window.onload = () => { new BondingApp(); };
</script>
</body>
</html>
